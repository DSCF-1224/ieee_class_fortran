#:mute

#! real kinds
#:set REAL_KINDS = ['real32', 'real64', 'real128']

#! ieee class
#:set IEEE_CLASSES = ['negative_inf', 'negative_zero', 'positive_inf', 'positive_zero']

#:endmute
module ieee_class_fortran


    #:for KIND in REAL_KINDS
    use, intrinsic :: iso_fortran_env, only: ${KIND}$
    #:endfor


    use, intrinsic :: ieee_arithmetic, only: operator(.eq.)
    use, intrinsic :: ieee_arithmetic, only: ieee_class
    #:for IEEE_CLASS in IEEE_CLASSES
    use, intrinsic :: ieee_arithmetic, only: ieee_${IEEE_CLASS}$
    #:endfor


    implicit none


    private
    #:for IEEE_CLASS in IEEE_CLASSES
    public  :: is_ieee_${IEEE_CLASS}$
    #:endfor

    #:for IEEE_CLASS in IEEE_CLASSES

    !> Checks whether `x` is `ieee_${IEEE_CLASS}$`
    interface is_ieee_${IEEE_CLASS}$
    #:for REAL_KIND in REAL_KINDS
        module procedure :: is_ieee_${IEEE_CLASS}$_${REAL_KIND}$
    #:endfor
    end interface

    #:endfor

    contains
    #:for IEEE_CLASS in IEEE_CLASSES

    #:for REAL_KIND in REAL_KINDS

    !> Checks whether `x` is `ieee_${IEEE_CLASS}$`
    logical pure elemental function is_ieee_${IEEE_CLASS}$_${REAL_KIND}$(x) result(status)

        real(${REAL_KIND}$), intent(in) :: x

        status = ieee_class(x) .eq. ieee_${IEEE_CLASS}$

    end function

    #:endfor

    #:endfor
end module ieee_class_fortran
